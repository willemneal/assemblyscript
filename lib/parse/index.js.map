{"version":3,"sources":["webpack://asparse/webpack/universalModuleDefinition","webpack://asparse/webpack/bootstrap","webpack://asparse/../host/src/ASImport.ts","webpack://asparse/../host/src/env.ts","webpack://asparse/../host/src/host.ts","webpack://asparse/../host/src/index.ts","webpack://asparse/../loader/lib/index.js","webpack://asparse/./src/common.ts","webpack://asparse/./src/index.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDa;AACb,8CAA8C,cAAc;AAC5D;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,2CAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C,4BAA4B,EAAE,KAAK,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC,cAAc,2BAA2B;AACzC;AACA;AACA;;;;;;;;;;;;;AC/Ba;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,2CAAY;AAC7B,SAAS,mBAAO,CAAC,mCAAQ;AACzB,SAAS,mBAAO,CAAC,iCAAO;;;;;;;;;;;;;ACPX;AACb;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,uEAAuE;AACvE;AACA,6BAA6B;AAC7B,iCAAiC;AACjC,0CAA0C;AAC1C,oCAAoC;AACpC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,kCAAkC,gBAAgB,MAAM,gBAAgB,IAAI,KAAK,GAAG,KAAK;AACzF;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oCAAoC;AACzE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,oCAAoC,iDAAiD,EAAE;AACvF;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,eAAe,WAAW;AAC1B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvda;AACb;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2CAA2C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iDAAiD;;;;;;;;;;;;;AChOrC;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,iCAAU;AACnC;AACA;AACA;AACA,eAAe,mBAAO,CAAC,gDAAkB;AACzC;AACA,WAAW,WAAW;AACtB,cAAc,mBAAO,CAAC,4CAAgB;AACtC,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"asparse\"] = factory();\n\telse\n\t\troot[\"asparse\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ASImport {\n    get __imports__() {\n        let constructor = this.constructor;\n        let className = constructor.name.toLowerCase();\n        let __imports__ = {};\n        let _this = this;\n        __imports__[className] = {\n            _bindMemory(memory) {\n                _this.__bindMemory(memory);\n            },\n            _bindInstance(instance) {\n                _this.instance = instance;\n            }\n        };\n        for (let name of Object.getOwnPropertyNames(constructor.prototype)) {\n            if (name !== \"constructor\" && !name.startsWith(\"__\")) {\n                __imports__[className][name] = this[name].bind(this);\n            }\n        }\n        return __imports__;\n    }\n    get memory() {\n        return (this.instance && this.instance.memory) || this._memory;\n    }\n    get table() {\n        return this.instance.table;\n    }\n    __bindInstance(instance) {\n        this.instance = instance;\n    }\n    __bindMemory(memory) {\n        this._memory = memory;\n    }\n    static createImport(...args) {\n        let imports = {};\n        for (let arg of args) {\n            let obj;\n            if (typeof arg == \"function\") {\n                obj = new arg();\n            }\n            else {\n                obj = arg;\n            }\n            imports = Object.assign({}, imports, obj.__imports__);\n        }\n        return imports;\n    }\n}\nexports.ASImport = ASImport;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Env {\n    constructor(memory = { initial: 10000 }) {\n        this.memory = new WebAssembly.Memory(memory);\n    }\n    static fromMemory(memory) {\n        let env = new Env();\n        env.memory = memory;\n        return env;\n    }\n    get __imports__() {\n        let memory = this.memory;\n        return {\n            \"env\": {\n                memory\n            }\n        };\n    }\n}\nexports.Env = Env;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ASImport_1 = require(\"./ASImport\");\nclass Host extends ASImport_1.ASImport {\n    debug() {\n        // tslint:disable-next-line\n        debugger;\n    }\n    _log(start, sizeof) {\n        let begin = start >> 2;\n        let size = sizeof >> 2;\n        let str = [];\n        let len = 0;\n        for (let i = begin; i < begin + size; i++) {\n            let line = `| ${i} | ${this.memory.I32[i] >> 2}`;\n            len = Math.max(len, line.length);\n            str.push(line);\n        }\n        let space = \" \";\n        let output = str.map((v, i, a) => v + space.repeat(len - v.length + 1) + \"|\");\n        let dash = \"-\";\n        let line = dash.repeat(len + 2);\n        Host.stdout([line, output.join('\\n' + line + '\\n'), line].join(\"\\n\"));\n    }\n    _log_str(x) {\n        return Host.stdout(x);\n    }\n    _logi(x) { Host.stdout(x.toString()); }\n    _logf(x) { Host.stdout(x.toString()); }\n}\nHost.stdout = console.log;\nexports.Host = Host;\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./ASImport\"));\n__export(require(\"./host\"));\n__export(require(\"./env\"));\n","\"use strict\";\n/** AssemblyScript module loader. */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ORIG_REF = Symbol('original');\nconst SELF_REF = Symbol('self');\nvar utils;\n(function (utils) {\n    utils.hasBigInt64 = typeof BigUint64Array !== 'undefined';\n    function readString(U32, U16, ptr) {\n        const chunkSize = 1024;\n        const dataLength = U32[ptr >>> 2];\n        let dataOffset = (ptr + 4) >>> 1;\n        let dataRemain = dataLength;\n        const parts = [];\n        while (dataRemain > chunkSize) {\n            const last = U16[dataOffset + chunkSize - 1];\n            const size = last >= 0xD800 && last < 0xDC00 ? chunkSize - 1 : chunkSize;\n            const part = U16.subarray(dataOffset, dataOffset += size);\n            parts.push(String.fromCharCode.apply(String, part));\n            dataRemain -= size;\n        }\n        const lastPart = U16.subarray(dataOffset, dataOffset + dataRemain);\n        parts.push(String.fromCharCode.apply(String, lastPart));\n        return parts.join('');\n    }\n    utils.readString = readString;\n    function computeBufferSize(byteLength) {\n        const HEADER_SIZE = 8;\n        return 1 << (32 - Math.clz32(byteLength + HEADER_SIZE - 1));\n    }\n    utils.computeBufferSize = computeBufferSize;\n    function hasOwnProperty(obj, key) {\n        return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n    utils.hasOwnProperty = hasOwnProperty;\n})(utils = exports.utils || (exports.utils = {}));\nclass MemoryWrapper {\n    static resolve(value) {\n        if (value instanceof MemoryWrapper) {\n            return value;\n        }\n        else {\n            return new MemoryWrapper(value);\n        }\n    }\n    constructor(memory) {\n        this.raw = memory;\n    }\n    // ASMemory conformance\n    newString(str) {\n        const dataLength = str.length;\n        const ptr = this.allocate(4 + (dataLength << 1));\n        const dataOffset = (4 + ptr) >>> 1;\n        const U32 = this.U32, U16 = this.U16;\n        U32[ptr >>> 2] = dataLength;\n        for (let i = 0; i < dataLength; ++i) {\n            U16[dataOffset + i] = str.charCodeAt(i);\n        }\n        return ptr;\n    }\n    getString(ptr) {\n        return utils.readString(this.U32, this.U16, ptr);\n    }\n    newArray(viewOrCtor, length, unsafe) {\n        let ctor;\n        let view;\n        if (viewOrCtor.constructor === Function) { // TypedArray constructor created in memory\n            ctor = viewOrCtor;\n            view = null;\n        }\n        else { // TypedArray instance copied into memory\n            ctor = viewOrCtor.constructor;\n            view = viewOrCtor;\n            if (length === undefined) {\n                length = viewOrCtor.length;\n            }\n        }\n        if (length === undefined) {\n            throw new Error('Length missing');\n        }\n        const elementSize = ctor.BYTES_PER_ELEMENT;\n        if (!elementSize) {\n            throw Error('Not a typed array');\n        }\n        const byteLength = elementSize * length;\n        const ptr = this.allocate(12); // TypedArray header\n        const buf = this.allocate(utils.computeBufferSize(byteLength)); // ArrayBuffer\n        const U32 = this.U32;\n        U32[ptr >>> 2] = buf; // .buffer\n        U32[(ptr + 4) >>> 2] = 0; // .byteOffset\n        U32[(ptr + 8) >>> 2] = byteLength; // .byteLength\n        U32[buf >>> 2] = byteLength; // .byteLength\n        U32[(buf + 4) >>> 2] = 0; // 0\n        if (view) {\n            new ctor(this.buffer, buf + 8, length).set(view);\n            if (view.length < length && !unsafe) {\n                const setLength = elementSize * view.length;\n                this.fill(buf + 8 + setLength, 0, byteLength - setLength);\n            }\n        }\n        else if (!unsafe) {\n            this.fill(buf + 8, 0, byteLength);\n        }\n        return ptr;\n    }\n    getArray(ctor, ptr) {\n        const elementSize = ctor.BYTES_PER_ELEMENT;\n        if (!elementSize) {\n            throw Error('Not a typed array');\n        }\n        const U32 = this.U32;\n        const buf = U32[ptr >>> 2];\n        const byteOffset = U32[(ptr + 4) >>> 2];\n        const byteLength = U32[(ptr + 8) >>> 2];\n        return new ctor(this.buffer, buf + 8 + byteOffset, (byteLength - byteOffset) / elementSize);\n    }\n    freeArray(ptr) {\n        const buf = this.U32[ptr >>> 2];\n        this.free(buf);\n        this.free(ptr);\n    }\n    get U8() {\n        if (!this._U8 || this._U8.buffer !== this.raw.buffer) {\n            this._U8 = new Uint8Array(this.raw.buffer);\n        }\n        return this._U8;\n    }\n    get U16() {\n        if (!this._U16 || this._U16.buffer !== this.raw.buffer) {\n            this._U16 = new Uint16Array(this.raw.buffer);\n        }\n        return this._U16;\n    }\n    get U32() {\n        if (!this._U32 || this._U32.buffer !== this.raw.buffer) {\n            this._U32 = new Uint32Array(this.raw.buffer);\n        }\n        return this._U32;\n    }\n    get U64() {\n        if (!utils.hasBigInt64) {\n            return;\n        }\n        if (!this._U64 || this._U64.buffer !== this.raw.buffer) {\n            this._U64 = new BigUint64Array(this.raw.buffer);\n        }\n        return this._U64;\n    }\n    get I8() {\n        if (!this._I8 || this._I8.buffer !== this.raw.buffer) {\n            this._I8 = new Int8Array(this.raw.buffer);\n        }\n        return this._I8;\n    }\n    get I16() {\n        if (!this._I16 || this._I16.buffer !== this.raw.buffer) {\n            this._I16 = new Int16Array(this.raw.buffer);\n        }\n        return this._I16;\n    }\n    get I32() {\n        if (!this._I32 || this._I32.buffer !== this.raw.buffer) {\n            this._I32 = new Int32Array(this.raw.buffer);\n        }\n        return this._I32;\n    }\n    get I64() {\n        if (!utils.hasBigInt64) {\n            return;\n        }\n        if (!this._I64 || this._I64.buffer !== this.raw.buffer) {\n            this._I64 = new BigInt64Array(this.raw.buffer);\n        }\n        return this._I64;\n    }\n    get F32() {\n        if (!this._F32 || this._F32.buffer !== this.raw.buffer) {\n            this._F32 = new Float32Array(this.raw.buffer);\n        }\n        return this._F32;\n    }\n    get F64() {\n        if (!this._F64 || this._F64.buffer !== this.raw.buffer) {\n            this._F64 = new Float64Array(this.raw.buffer);\n        }\n        return this._F64;\n    }\n    allocate(size) {\n        throw new Error('Memory not initialized');\n    }\n    compare(vl, vr, n) {\n        throw new Error('Memory not initialized');\n    }\n    copy(dest, src, n) {\n        throw new Error('Memory not initialized');\n    }\n    fill(ptr, value, size) {\n        throw new Error('Memory not initialized');\n    }\n    free(ptr) {\n        throw new Error('Memory not initialized');\n    }\n    reset() {\n        throw new Error('Memory not initialized');\n    }\n    // WebAssembly.Memory conformance\n    grow(numPages) {\n        return this.raw.grow(numPages);\n    }\n    get buffer() {\n        return this.raw.buffer;\n    }\n    // Internal methods\n    setExports(rawExports) {\n        const methods = ['allocate', 'compare', 'copy', 'fill', 'free', 'reset'];\n        for (const method of methods) {\n            const exportedMethod = `memory.${method}`;\n            if (rawExports[exportedMethod]) {\n                this[method] = rawExports[exportedMethod];\n            }\n            else {\n                this[method] = () => { throw new Error('Method not exported'); };\n            }\n        }\n    }\n}\nclass TableWrapper {\n    constructor(table) {\n        this.raw = table;\n    }\n    // ASTable conformance\n    getFunction(ptr) {\n        return this.wrapFunction(this.get(ptr));\n    }\n    newFunction(fn) {\n        if (typeof fn[ORIG_REF] === 'function') {\n            fn = fn[ORIG_REF];\n        }\n        const index = this.length;\n        this.grow(1);\n        this.set(index, fn);\n        return index;\n    }\n    // WebAssembly.Table conformance\n    grow(numElements) {\n        return this.raw.grow(numElements);\n    }\n    set(index, value) {\n        return this.raw.set(index, value);\n    }\n    get(index) {\n        return this.raw.get(index);\n    }\n    get length() {\n        return this.raw.length;\n    }\n    // Internal methods\n    setargc(n) { }\n    /** Wraps a WebAssembly function while also taking care of variable arguments. */\n    wrapFunction(fn) {\n        const wrap = (...args) => {\n            this.setargc(args.length);\n            let _args = args.map(e => e[SELF_REF] | e);\n            return fn(...args);\n        };\n        // adding a function to the table with `newFunction` is limited to actual WebAssembly functions,\n        // hence we can't use the wrapper and instead need to provide a reference to the original\n        wrap[ORIG_REF] = fn;\n        return wrap;\n    }\n    setExports(rawExports) {\n        if (rawExports._setargc) {\n            this.setargc = rawExports._setargc;\n        }\n    }\n}\nfunction createContext(imports = {}) {\n    const ctx = {\n        imports,\n        memory: imports.memory ? MemoryWrapper.resolve(imports.memory) : null,\n    };\n    const env = (imports.env = imports.env || {});\n    const getString = (ptr) => ctx.memory ? ctx.memory.getString(ptr) : '<unknown>';\n    if (!env.abort) {\n        env.abort = function abort(mesg, file, line, colm) {\n            throw Error(`Abort: ${getString(mesg)} at ${getString(file)}: ${line}:${colm}`);\n        };\n    }\n    if (!env.trace) {\n        env.trace = function trace(mesg, n, ...args) {\n            let msg = `trace: ${getString(mesg)}`;\n            if (n) {\n                msg += ` ${args.slice(0, n).join(', ')}`;\n            }\n            console.log(msg);\n        };\n    }\n    if (env.memory instanceof MemoryWrapper) {\n        env.memory = env.memory.raw;\n    }\n    for (let _import in ctx.imports) {\n        if (ctx.imports[_import]._bindMemory) {\n            ctx.imports[_import]._bindMemory(ctx.memory);\n        }\n    }\n    return ctx;\n}\nfunction resolveContext(instance, ctx) {\n    const table = new TableWrapper(instance.exports.table);\n    table.setExports(instance.exports);\n    ctx.memory = MemoryWrapper.resolve(instance.exports.memory);\n    ctx.memory.setExports(instance.exports);\n    let resolved = {\n        \"String\": { wrap: (x) => ctx.memory.getString(x) },\n        \"Uint8Array\": { wrap: (x) => ctx.memory.getArray(Uint8Array, x) }\n    };\n    for (const internalName in instance.exports) {\n        if (!utils.hasOwnProperty(instance.exports, internalName)) {\n            continue;\n        }\n        // resolve nested objects\n        const parts = internalName.split('.');\n        let name = parts[0];\n        // ignore internals\n        if (name === 'memory' || name === 'table' || name === '_setargc') {\n            continue;\n        }\n        let curr = resolved;\n        while (parts.length > 1) {\n            const part = parts.shift();\n            if (!utils.hasOwnProperty(curr, part)) {\n                curr[part] = {};\n            }\n            curr = curr[part];\n        }\n        const elem = instance.exports[internalName];\n        const hash = name.indexOf('#');\n        let bang = name.indexOf('!');\n        let refType = bang > 0 ? name.substring(bang + 1) : null;\n        if (refType) {\n            name = name.substring(0, bang);\n        }\n        if (hash >= 0) {\n            // resolve classes\n            const className = name.substring(0, hash);\n            const classElem = curr[className];\n            if (typeof classElem === 'undefined' || !classElem.prototype) {\n                const ctor = function (...args) {\n                    let _args = args.map(e => e[SELF_REF] | e);\n                    debugger;\n                    return ctor.wrap(ctor.prototype.constructor(0, ..._args));\n                };\n                ctor.prototype = {};\n                ctor.wrap = function (thisValue) {\n                    return Object.create(ctor.prototype, {\n                        [SELF_REF]: { value: thisValue, writable: false },\n                    });\n                };\n                if (classElem) {\n                    Object.getOwnPropertyNames(classElem).forEach((propName) => {\n                        console.log(classElem.constructor.name + \" \" + propName);\n                        Object.defineProperty(ctor, propName, Object.getOwnPropertyDescriptor(classElem, propName));\n                    });\n                }\n                curr[className] = ctor;\n            }\n            name = name.substring(hash + 1);\n            curr = curr[className].prototype;\n            if (/^(get|set):/.test(name)) {\n                name = name.substring(4);\n                if (!utils.hasOwnProperty(curr, name)) {\n                    const getter = instance.exports[internalName.replace('set:', 'get:')];\n                    const setter = instance.exports[internalName.replace('get:', 'set:')];\n                    Object.defineProperty(curr, name, {\n                        get() {\n                            let ptr = getter(this[SELF_REF]);\n                            return refType && resolved[refType] ? resolved[refType].wrap(ptr) : ptr;\n                        },\n                        set(value) { setter(this[SELF_REF], value[SELF_REF] | value); },\n                        enumerable: true,\n                    });\n                }\n            }\n            else {\n                if (name === 'constructor') {\n                    curr[name] = table.wrapFunction(elem);\n                }\n                else { // for methods\n                    Object.defineProperty(curr, name, {\n                        value(...args) {\n                            table.setargc(args.length);\n                            let _args = args.map(e => e[SELF_REF] | e);\n                            let ptr = elem(this[SELF_REF], ..._args);\n                            return refType && resolved[refType] ? resolved[refType].wrap(ptr) : ptr;\n                        },\n                    });\n                }\n            }\n        }\n        else {\n            // resolve props\n            if (/^(get|set):/.test(name)) {\n                name = name.substring(4);\n                if (!utils.hasOwnProperty(curr, name)) {\n                    Object.defineProperty(curr, name, {\n                        get: instance.exports[internalName.replace('set:', 'get:')],\n                        set: instance.exports[internalName.replace('get:', 'set:')],\n                        enumerable: true,\n                    });\n                }\n            }\n            else if (typeof elem === 'function') {\n                curr[name] = table.wrapFunction(elem);\n            }\n            else {\n                curr[name] = elem;\n            }\n        }\n    }\n    resolved = Object.assign({ memory: ctx.memory, table }, resolved);\n    for (let _import in ctx.imports) {\n        if (ctx.imports[_import]._bindInstance) {\n            ctx.imports[_import]._bindInstance(resolved);\n        }\n    }\n    return resolved;\n}\n/** Instantiates an AssemblyScript module using the specified imports. */\nfunction instantiate(module, imports = {}) {\n    const ctx = createContext(imports);\n    const instance = new WebAssembly.Instance(module, ctx.imports);\n    var res = resolveContext(instance, ctx);\n    return res;\n}\nexports.instantiate = instantiate;\n/** Instantiates an AssemblyScript module from a buffer using the specified imports. */\nfunction instantiateBuffer(buffer, imports = {}) {\n    // if (imports.pre){\n    //   imports.pre.map((fn)=>{\n    //     _buffer = fn(_buffer);\n    //   })\n    // }\n    return instantiate(new WebAssembly.Module(buffer), imports);\n}\nexports.instantiateBuffer = instantiateBuffer;\n/** Instantiates an AssemblyScript module from a response using the specified imports. */\nfunction instantiateStreaming(response, imports = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const ctx = createContext(imports);\n        const { instance } = yield WebAssembly.instantiateStreaming(response, ctx.imports);\n        return resolveContext(instance, ctx);\n    });\n}\nexports.instantiateStreaming = instantiateStreaming;\n/** Creates a wrapped memory instance. */\nfunction createMemory(descriptor) {\n    return new MemoryWrapper(new WebAssembly.Memory(descriptor));\n}\nexports.createMemory = createMemory;\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(instance) {\n    return resolveContext(instance, createContext());\n}\nexports.demangle = demangle;\n","\"use strict\";\n/** Common constants shared between AssemblyScript and TypeScript. */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** WebAssembly types. */\nvar Type;\n(function (Type) {\n    Type[Type[\"i32\"] = 127] = \"i32\";\n    Type[Type[\"i64\"] = 126] = \"i64\";\n    Type[Type[\"f32\"] = 125] = \"f32\";\n    Type[Type[\"f64\"] = 124] = \"f64\";\n    Type[Type[\"anyfunc\"] = 112] = \"anyfunc\";\n    Type[Type[\"func\"] = 96] = \"func\";\n    Type[Type[\"none\"] = 64] = \"none\";\n})(Type = exports.Type || (exports.Type = {}));\n/** WebAssembly section ids. */\nvar SectionId;\n(function (SectionId) {\n    SectionId[SectionId[\"Custom\"] = 0] = \"Custom\";\n    SectionId[SectionId[\"Type\"] = 1] = \"Type\";\n    SectionId[SectionId[\"Import\"] = 2] = \"Import\";\n    SectionId[SectionId[\"Function\"] = 3] = \"Function\";\n    SectionId[SectionId[\"Table\"] = 4] = \"Table\";\n    SectionId[SectionId[\"Memory\"] = 5] = \"Memory\";\n    SectionId[SectionId[\"Global\"] = 6] = \"Global\";\n    SectionId[SectionId[\"Export\"] = 7] = \"Export\";\n    SectionId[SectionId[\"Start\"] = 8] = \"Start\";\n    SectionId[SectionId[\"Element\"] = 9] = \"Element\";\n    SectionId[SectionId[\"Code\"] = 10] = \"Code\";\n    SectionId[SectionId[\"Data\"] = 11] = \"Data\";\n})(SectionId = exports.SectionId || (exports.SectionId = {}));\n/** WebAssembly external kinds. */\nvar ExternalKind;\n(function (ExternalKind) {\n    ExternalKind[ExternalKind[\"Function\"] = 0] = \"Function\";\n    ExternalKind[ExternalKind[\"Table\"] = 1] = \"Table\";\n    ExternalKind[ExternalKind[\"Memory\"] = 2] = \"Memory\";\n    ExternalKind[ExternalKind[\"Global\"] = 3] = \"Global\";\n})(ExternalKind = exports.ExternalKind || (exports.ExternalKind = {}));\n/** Name section types. */\nvar NameType;\n(function (NameType) {\n    NameType[NameType[\"Module\"] = 0] = \"Module\";\n    NameType[NameType[\"Function\"] = 1] = \"Function\";\n    NameType[NameType[\"Local\"] = 2] = \"Local\";\n})(NameType = exports.NameType || (exports.NameType = {}));\n/** Maximum number of memory pages. */\nexports.MAX_PAGES = 0xffff;\n/** Maximum number of table elements. */\nexports.MAX_ELEMS = 0xffffffff;\n/** WebAssembly opcodes. */\nvar Opcode;\n(function (Opcode) {\n    Opcode[Opcode[\"unreachable\"] = 0] = \"unreachable\";\n    Opcode[Opcode[\"nop\"] = 1] = \"nop\";\n    Opcode[Opcode[\"block\"] = 2] = \"block\";\n    Opcode[Opcode[\"loop\"] = 3] = \"loop\";\n    Opcode[Opcode[\"if_\"] = 4] = \"if_\";\n    Opcode[Opcode[\"else_\"] = 5] = \"else_\";\n    Opcode[Opcode[\"end\"] = 11] = \"end\";\n    Opcode[Opcode[\"br\"] = 12] = \"br\";\n    Opcode[Opcode[\"br_if\"] = 13] = \"br_if\";\n    Opcode[Opcode[\"br_table\"] = 14] = \"br_table\";\n    Opcode[Opcode[\"return_\"] = 15] = \"return_\";\n    Opcode[Opcode[\"call\"] = 16] = \"call\";\n    Opcode[Opcode[\"call_indirect\"] = 17] = \"call_indirect\";\n    Opcode[Opcode[\"drop\"] = 26] = \"drop\";\n    Opcode[Opcode[\"select\"] = 27] = \"select\";\n    Opcode[Opcode[\"get_local\"] = 32] = \"get_local\";\n    Opcode[Opcode[\"set_local\"] = 33] = \"set_local\";\n    Opcode[Opcode[\"tee_local\"] = 34] = \"tee_local\";\n    Opcode[Opcode[\"get_global\"] = 35] = \"get_global\";\n    Opcode[Opcode[\"set_global\"] = 36] = \"set_global\";\n    Opcode[Opcode[\"i32_load\"] = 40] = \"i32_load\";\n    Opcode[Opcode[\"i64_load\"] = 41] = \"i64_load\";\n    Opcode[Opcode[\"f32_load\"] = 42] = \"f32_load\";\n    Opcode[Opcode[\"f64_load\"] = 43] = \"f64_load\";\n    Opcode[Opcode[\"i32_load8_s\"] = 44] = \"i32_load8_s\";\n    Opcode[Opcode[\"i32_load8_u\"] = 45] = \"i32_load8_u\";\n    Opcode[Opcode[\"i32_load16_s\"] = 46] = \"i32_load16_s\";\n    Opcode[Opcode[\"i32_load16_u\"] = 47] = \"i32_load16_u\";\n    Opcode[Opcode[\"i64_load8_s\"] = 48] = \"i64_load8_s\";\n    Opcode[Opcode[\"i64_load8_u\"] = 49] = \"i64_load8_u\";\n    Opcode[Opcode[\"i64_load16_s\"] = 50] = \"i64_load16_s\";\n    Opcode[Opcode[\"i64_load16_u\"] = 51] = \"i64_load16_u\";\n    Opcode[Opcode[\"i64_load32_s\"] = 52] = \"i64_load32_s\";\n    Opcode[Opcode[\"i64_load32_u\"] = 53] = \"i64_load32_u\";\n    Opcode[Opcode[\"i32_store\"] = 54] = \"i32_store\";\n    Opcode[Opcode[\"i64_store\"] = 55] = \"i64_store\";\n    Opcode[Opcode[\"f32_store\"] = 56] = \"f32_store\";\n    Opcode[Opcode[\"f64_store\"] = 57] = \"f64_store\";\n    Opcode[Opcode[\"i32_store8\"] = 58] = \"i32_store8\";\n    Opcode[Opcode[\"i32_store16\"] = 59] = \"i32_store16\";\n    Opcode[Opcode[\"i64_store8\"] = 60] = \"i64_store8\";\n    Opcode[Opcode[\"i64_store16\"] = 61] = \"i64_store16\";\n    Opcode[Opcode[\"i64_store32\"] = 62] = \"i64_store32\";\n    Opcode[Opcode[\"current_memory\"] = 63] = \"current_memory\";\n    Opcode[Opcode[\"grow_memory\"] = 64] = \"grow_memory\";\n    Opcode[Opcode[\"i32_const\"] = 65] = \"i32_const\";\n    Opcode[Opcode[\"i64_const\"] = 66] = \"i64_const\";\n    Opcode[Opcode[\"f32_const\"] = 67] = \"f32_const\";\n    Opcode[Opcode[\"f64_const\"] = 68] = \"f64_const\";\n    Opcode[Opcode[\"i32_eqz\"] = 69] = \"i32_eqz\";\n    Opcode[Opcode[\"i32_eq\"] = 70] = \"i32_eq\";\n    Opcode[Opcode[\"i32_ne\"] = 71] = \"i32_ne\";\n    Opcode[Opcode[\"i32_lt_s\"] = 72] = \"i32_lt_s\";\n    Opcode[Opcode[\"i32_lt_u\"] = 73] = \"i32_lt_u\";\n    Opcode[Opcode[\"i32_gt_s\"] = 74] = \"i32_gt_s\";\n    Opcode[Opcode[\"i32_gt_u\"] = 75] = \"i32_gt_u\";\n    Opcode[Opcode[\"i32_le_s\"] = 76] = \"i32_le_s\";\n    Opcode[Opcode[\"i32_le_u\"] = 77] = \"i32_le_u\";\n    Opcode[Opcode[\"i32_ge_s\"] = 78] = \"i32_ge_s\";\n    Opcode[Opcode[\"i32_ge_u\"] = 79] = \"i32_ge_u\";\n    Opcode[Opcode[\"i64_eqz\"] = 80] = \"i64_eqz\";\n    Opcode[Opcode[\"i64_eq\"] = 81] = \"i64_eq\";\n    Opcode[Opcode[\"i64_ne\"] = 82] = \"i64_ne\";\n    Opcode[Opcode[\"i64_lt_s\"] = 83] = \"i64_lt_s\";\n    Opcode[Opcode[\"i64_lt_u\"] = 84] = \"i64_lt_u\";\n    Opcode[Opcode[\"i64_gt_s\"] = 85] = \"i64_gt_s\";\n    Opcode[Opcode[\"i64_gt_u\"] = 86] = \"i64_gt_u\";\n    Opcode[Opcode[\"i64_le_s\"] = 87] = \"i64_le_s\";\n    Opcode[Opcode[\"i64_le_u\"] = 88] = \"i64_le_u\";\n    Opcode[Opcode[\"i64_ge_s\"] = 89] = \"i64_ge_s\";\n    Opcode[Opcode[\"i64_ge_u\"] = 90] = \"i64_ge_u\";\n    Opcode[Opcode[\"f32_eq\"] = 91] = \"f32_eq\";\n    Opcode[Opcode[\"f32_ne\"] = 92] = \"f32_ne\";\n    Opcode[Opcode[\"f32_lt\"] = 93] = \"f32_lt\";\n    Opcode[Opcode[\"f32_gt\"] = 94] = \"f32_gt\";\n    Opcode[Opcode[\"f32_le\"] = 95] = \"f32_le\";\n    Opcode[Opcode[\"f32_ge\"] = 96] = \"f32_ge\";\n    Opcode[Opcode[\"f64_eq\"] = 97] = \"f64_eq\";\n    Opcode[Opcode[\"f64_ne\"] = 98] = \"f64_ne\";\n    Opcode[Opcode[\"f64_lt\"] = 99] = \"f64_lt\";\n    Opcode[Opcode[\"f64_gt\"] = 100] = \"f64_gt\";\n    Opcode[Opcode[\"f64_le\"] = 101] = \"f64_le\";\n    Opcode[Opcode[\"f64_ge\"] = 102] = \"f64_ge\";\n    Opcode[Opcode[\"i32_clz\"] = 103] = \"i32_clz\";\n    Opcode[Opcode[\"i32_ctz\"] = 104] = \"i32_ctz\";\n    Opcode[Opcode[\"i32_popcnt\"] = 105] = \"i32_popcnt\";\n    Opcode[Opcode[\"i32_add\"] = 106] = \"i32_add\";\n    Opcode[Opcode[\"i32_sub\"] = 107] = \"i32_sub\";\n    Opcode[Opcode[\"i32_mul\"] = 108] = \"i32_mul\";\n    Opcode[Opcode[\"i32_div_s\"] = 109] = \"i32_div_s\";\n    Opcode[Opcode[\"i32_div_u\"] = 110] = \"i32_div_u\";\n    Opcode[Opcode[\"i32_rem_s\"] = 111] = \"i32_rem_s\";\n    Opcode[Opcode[\"i32_rem_u\"] = 112] = \"i32_rem_u\";\n    Opcode[Opcode[\"i32_and\"] = 113] = \"i32_and\";\n    Opcode[Opcode[\"i32_or\"] = 114] = \"i32_or\";\n    Opcode[Opcode[\"i32_xor\"] = 115] = \"i32_xor\";\n    Opcode[Opcode[\"i32_shl\"] = 116] = \"i32_shl\";\n    Opcode[Opcode[\"i32_shr_s\"] = 117] = \"i32_shr_s\";\n    Opcode[Opcode[\"i32_shr_u\"] = 118] = \"i32_shr_u\";\n    Opcode[Opcode[\"i32_rotl\"] = 119] = \"i32_rotl\";\n    Opcode[Opcode[\"i32_rotr\"] = 120] = \"i32_rotr\";\n    Opcode[Opcode[\"i64_clz\"] = 121] = \"i64_clz\";\n    Opcode[Opcode[\"i64_ctz\"] = 122] = \"i64_ctz\";\n    Opcode[Opcode[\"i64_popcnt\"] = 123] = \"i64_popcnt\";\n    Opcode[Opcode[\"i64_add\"] = 124] = \"i64_add\";\n    Opcode[Opcode[\"i64_sub\"] = 125] = \"i64_sub\";\n    Opcode[Opcode[\"i64_mul\"] = 126] = \"i64_mul\";\n    Opcode[Opcode[\"i64_div_s\"] = 127] = \"i64_div_s\";\n    Opcode[Opcode[\"i64_div_u\"] = 128] = \"i64_div_u\";\n    Opcode[Opcode[\"i64_rem_s\"] = 129] = \"i64_rem_s\";\n    Opcode[Opcode[\"i64_rem_u\"] = 130] = \"i64_rem_u\";\n    Opcode[Opcode[\"i64_and\"] = 131] = \"i64_and\";\n    Opcode[Opcode[\"i64_or\"] = 132] = \"i64_or\";\n    Opcode[Opcode[\"i64_xor\"] = 133] = \"i64_xor\";\n    Opcode[Opcode[\"i64_shl\"] = 134] = \"i64_shl\";\n    Opcode[Opcode[\"i64_shr_s\"] = 135] = \"i64_shr_s\";\n    Opcode[Opcode[\"i64_shr_u\"] = 136] = \"i64_shr_u\";\n    Opcode[Opcode[\"i64_rotl\"] = 137] = \"i64_rotl\";\n    Opcode[Opcode[\"i64_rotr\"] = 138] = \"i64_rotr\";\n    Opcode[Opcode[\"f32_abs\"] = 139] = \"f32_abs\";\n    Opcode[Opcode[\"f32_neg\"] = 140] = \"f32_neg\";\n    Opcode[Opcode[\"f32_ceil\"] = 141] = \"f32_ceil\";\n    Opcode[Opcode[\"f32_floor\"] = 142] = \"f32_floor\";\n    Opcode[Opcode[\"f32_trunc\"] = 143] = \"f32_trunc\";\n    Opcode[Opcode[\"f32_nearest\"] = 144] = \"f32_nearest\";\n    Opcode[Opcode[\"f32_sqrt\"] = 145] = \"f32_sqrt\";\n    Opcode[Opcode[\"f32_add\"] = 146] = \"f32_add\";\n    Opcode[Opcode[\"f32_sub\"] = 147] = \"f32_sub\";\n    Opcode[Opcode[\"f32_mul\"] = 148] = \"f32_mul\";\n    Opcode[Opcode[\"f32_div\"] = 149] = \"f32_div\";\n    Opcode[Opcode[\"f32_min\"] = 150] = \"f32_min\";\n    Opcode[Opcode[\"f32_max\"] = 151] = \"f32_max\";\n    Opcode[Opcode[\"f32_copysign\"] = 152] = \"f32_copysign\";\n    Opcode[Opcode[\"f64_abs\"] = 153] = \"f64_abs\";\n    Opcode[Opcode[\"f64_neg\"] = 154] = \"f64_neg\";\n    Opcode[Opcode[\"f64_ceil\"] = 155] = \"f64_ceil\";\n    Opcode[Opcode[\"f64_floor\"] = 156] = \"f64_floor\";\n    Opcode[Opcode[\"f64_trunc\"] = 157] = \"f64_trunc\";\n    Opcode[Opcode[\"f64_nearest\"] = 158] = \"f64_nearest\";\n    Opcode[Opcode[\"f64_sqrt\"] = 159] = \"f64_sqrt\";\n    Opcode[Opcode[\"f64_add\"] = 160] = \"f64_add\";\n    Opcode[Opcode[\"f64_sub\"] = 161] = \"f64_sub\";\n    Opcode[Opcode[\"f64_mul\"] = 162] = \"f64_mul\";\n    Opcode[Opcode[\"f64_div\"] = 163] = \"f64_div\";\n    Opcode[Opcode[\"f64_min\"] = 164] = \"f64_min\";\n    Opcode[Opcode[\"f64_max\"] = 165] = \"f64_max\";\n    Opcode[Opcode[\"f64_copysign\"] = 166] = \"f64_copysign\";\n    Opcode[Opcode[\"i32_wrap_i64\"] = 167] = \"i32_wrap_i64\";\n    Opcode[Opcode[\"i32_trunc_s_f32\"] = 168] = \"i32_trunc_s_f32\";\n    Opcode[Opcode[\"i32_trunc_u_f32\"] = 169] = \"i32_trunc_u_f32\";\n    Opcode[Opcode[\"i32_trunc_s_f64\"] = 170] = \"i32_trunc_s_f64\";\n    Opcode[Opcode[\"i32_trunc_u_f64\"] = 171] = \"i32_trunc_u_f64\";\n    Opcode[Opcode[\"i64_extend_s_i32\"] = 172] = \"i64_extend_s_i32\";\n    Opcode[Opcode[\"i64_extend_u_i32\"] = 173] = \"i64_extend_u_i32\";\n    Opcode[Opcode[\"i64_trunc_s_f32\"] = 174] = \"i64_trunc_s_f32\";\n    Opcode[Opcode[\"i64_trunc_u_f32\"] = 175] = \"i64_trunc_u_f32\";\n    Opcode[Opcode[\"i64_trunc_s_f64\"] = 176] = \"i64_trunc_s_f64\";\n    Opcode[Opcode[\"i64_trunc_u_f64\"] = 177] = \"i64_trunc_u_f64\";\n    Opcode[Opcode[\"f32_convert_s_i32\"] = 178] = \"f32_convert_s_i32\";\n    Opcode[Opcode[\"f32_convert_u_i32\"] = 179] = \"f32_convert_u_i32\";\n    Opcode[Opcode[\"f32_convert_s_i64\"] = 180] = \"f32_convert_s_i64\";\n    Opcode[Opcode[\"f32_convert_u_i64\"] = 181] = \"f32_convert_u_i64\";\n    Opcode[Opcode[\"f32_demote_f64\"] = 182] = \"f32_demote_f64\";\n    Opcode[Opcode[\"f64_convert_s_i32\"] = 183] = \"f64_convert_s_i32\";\n    Opcode[Opcode[\"f64_convert_u_i32\"] = 184] = \"f64_convert_u_i32\";\n    Opcode[Opcode[\"f64_convert_s_i64\"] = 185] = \"f64_convert_s_i64\";\n    Opcode[Opcode[\"f64_convert_u_i64\"] = 186] = \"f64_convert_u_i64\";\n    Opcode[Opcode[\"f64_promote_f32\"] = 187] = \"f64_promote_f32\";\n    Opcode[Opcode[\"i32_reinterpret_f32\"] = 188] = \"i32_reinterpret_f32\";\n    Opcode[Opcode[\"i64_reinterpret_f64\"] = 189] = \"i64_reinterpret_f64\";\n    Opcode[Opcode[\"f32_reinterpret_i32\"] = 190] = \"f32_reinterpret_i32\";\n    Opcode[Opcode[\"f64_reinterpret_i64\"] = 191] = \"f64_reinterpret_i64\";\n})(Opcode = exports.Opcode || (exports.Opcode = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = require(\"./common\");\nexports.Type = common_1.Type;\nexports.SectionId = common_1.SectionId;\nexports.ExternalKind = common_1.ExternalKind;\nconst loader = require(\"../../loader/lib\");\n// import ASModule from \"../build\";\n// import { ASImport } from \"./asImport\";\nconst src_1 = require(\"../../host/src\");\n// type Parser = {parse: (any)=> any, newParser: (any)=>any};\n/** Cached compiled parser. */\nvar compiled = null;\nvar WASM_DATA; // injected by webpack\n// if (typeof WASM_DATA !== \"string\") WASM_DATA = require(\"fs\").readFileSync(__dirname + \"/../build/index.wasm\", \"base64\");\nclass WasmParser {\n    constructor(binary) {\n        this.binary = binary;\n        // compile the parser if not yet compiled\n        if (!compiled)\n            compiled = new WebAssembly.Module(base64_decode(WASM_DATA));\n        // use the binary as the parser's memory\n        var nBytes = binary.length;\n        var nPages = ((nBytes + 0xffff) & ~0xffff) >> 16;\n        var imports = src_1.ASImport.createImport(src_1.Env, src_1.Host);\n        debugger;\n        this.instance = loader.instantiate(compiled, imports);\n        var array = this.memory.newArray(binary);\n        var parser = new this.instance.Parser(array);\n        this.parser = parser;\n        parser.parse();\n        this.mod = this.instance.Module.wrap(parser.module);\n        console.log(this.mod['self']);\n    }\n    get memory() {\n        return this.instance.memory;\n    }\n    getByteArray(addr) {\n        return this.memory.getArray(Uint8Array, addr);\n    }\n    get Type() {\n        return this.memory.getString(this.mod.getType());\n    }\n    printModule() {\n        this.mod.print();\n    }\n    removeStartFunction() {\n        var binary = this.instance.removeStartFunction(this.parser.module);\n        return binary;\n    }\n    hasSection(id) {\n        return this.mod.getID(id) != 0;\n    }\n    removeDataSection() {\n        return this.getByteArray(this.instance.removeSection(this.parser.module, common_1.SectionId.Data));\n    }\n    exportDataSection() {\n        return this.getByteArray(this.instance.exportDataSection(this.parser.module));\n    }\n    hasStart() {\n        return this.mod.hasStart;\n    }\n}\nexports.WasmParser = WasmParser;\n// see: https://github.com/dcodeIO/protobuf.js/tree/master/lib/base64\nfunction base64_decode(string) {\n    var length = string.length;\n    if (length) {\n        let n = 0, p = length;\n        while (--p % 4 > 1 && string.charCodeAt(p) === 61)\n            ++n;\n        length = Math.ceil(length * 3) / 4 - n;\n    }\n    var buffer = new Uint8Array(length);\n    var j = 0, o = 0, t = 0;\n    for (let i = 0, k = string.length; i < k;) {\n        let c = string.charCodeAt(i++);\n        if (c === 61 && j > 1)\n            break;\n        if ((c = s64[c]) === undefined)\n            throw Error();\n        switch (j) {\n            case 0: {\n                t = c;\n                j = 1;\n                break;\n            }\n            case 1: {\n                buffer[o++] = t << 2 | (c & 48) >> 4;\n                t = c;\n                j = 2;\n                break;\n            }\n            case 2: {\n                buffer[o++] = (t & 15) << 4 | (c & 60) >> 2;\n                t = c;\n                j = 3;\n                break;\n            }\n            case 3: {\n                buffer[o++] = (t & 3) << 6 | c;\n                j = 0;\n                break;\n            }\n        }\n    }\n    if (j === 1)\n        throw Error();\n    return buffer;\n}\nvar s64 = new Array(123);\nfor (let i = 0; i < 64;)\n    s64[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n"],"sourceRoot":""}